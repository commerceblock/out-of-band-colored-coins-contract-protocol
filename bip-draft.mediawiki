<pre>
  BIP: 999*
  Layer: Applications
  Title: Pay to Contract Protocol
  Author: Omar Shibli <omar@commerceblock.com>
          Nicholas Gregory <nicholas@commerceblock.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0999
  Status: Draft
  Type: Informational Track
  Created: 2017-07-17
</pre>

&ast; 999 is a temporary BIP number.

==Abstract==

This document describes a key derivation scheme based on hierarchical deterministic wallets as described in BIP-0032 (BIP32 from now on) and the "Purpose Field" in BIP-0032 BIP-0043 (BIP43 from now on).
This BIP is a particular application of BIP43.


The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

==Motivation==

A Bitcoin transaction represents a "real world" contract between two parties to transfer value. The payer may want cryptographic proof that the payee has agreed to the terms of this contract. Using the technique described in this BIP, an address can be provably derived from the terms of a contract in a completely hidden manner which does not bloat the UTXO. This schema can also be used as a foundation for a variety of protocols, such as advanced color coin schemes.

==Specification==

We define the following levels in BIP32 path:

<code>
m / purpose' / coin_type' / contract_id' / *
</code>

Apostrophe in the path indicates that BIP32 hardened derivation is used.

Each level has special meaning described in the chapters below.

===Purpose===

Purpose is a constant set to 999' (or 0x800003E7) following the BIP43 recommendation. It indicates that the subtree of this node is used according to this specification.

<code>
m / 999' / *
</code>

Hardened derivation is used at this level.

===Coin type===

The coin type field is identical to the same field in BIP-0044.

Hardened derivation is used at this level.

===Contract Id===

Contract id is an arbitrary number within the valid range of indices as defined in BIP32.

Hardened derivation is used at this level.

===Contract Base Derivation===

Contact base is the the public part of address, which is for a given `coin_type` and `contract_id` is derived by following path:

<code>
m / 999' / coin_type' / contract_id'
</code>

===Contract Address Generation===

For a given contract documents denoted by `c<sub>1</sub>,...,c<sub>n</sub>`, contract base extended public key denoted by `contract_base_pub`, and cryptographic hash function denoted by `h`.

1. compute cryptographic signatures for all contract documents, by applying the hash function.
<code>
h(c<sub>1</sub>),...,h(c<sub>n</sub>)
</code>

2. sort all signatures lexicographically.
<code>
s<sub>1</sub>,...,s<sub>n</sub>'
</code>

3. concatenate the sorted signatures and apply the hash function.
<code>
h(s<sub>1</sub>+...+s<sub>n</sub>)
</code>

4. Map the combined signature s<sub>all</sub> to a partial BIP32 derivation path as defined in Hash to Partial Derivation Path Mapping procedure below.
<code>
contract_signature
</code>

5. Prepend contract base to `contract_signature`.
<code>
contract_base_pub / contract_signature
or
m / 999' / coin_type' / contract_id' / contract_signature
</code>

6. Compute public extended key from the derivation path in step 5.

7. Compute address of the public extended key (P2PKH) from step 6.

===Contract Address Verification===

For a given Bitcoin address, contract base extended public key denoted by `contract_base_pub`, contract documents denoted by `c<sub>1</sub>,...,c<sub>n</sub>`, and cryptographic hash function denoted by `h`, we can verify the integrity of the address by the following steps:

1. Compute contract address as described in `Contract Address Generation` section.

2. Compare the computed address from step 2 with the given Bitcoin address.

===Hash to Partial Derivation Path Mapping===

At this section, we define hash to partial BIP32 derivation path mapping procedure that maps between an arbitrary hex number to a partial BIP32 derivation path.

For a given number, do the following:

1. Partition the number into parts, each part length should be 16.

2. Convert each part to integer in decimal format.

3. Concatenate all numbers with slash `/`.

==Examples==

For the following given inputs:
<code>
master private extended key: xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73
coin type: 0
contract id: 7777777
</code>

we can compute contract base as follows:

<code>
derivation path: m/999'/0'/7777777'
contract base public extended key: xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnniiD5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE
</code>

In the below examples, we going to use SHA256 as a cryptographic hash function, and the above contract base public key.

contract address generation:

As an input, we have a contract that consists two documents, below are contents:

document 1:
<code>
bar
</code>

document 2:
<code>
foo
</code>

first, apply the hash function:

<code>
fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9
</code>

<code>
2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae
</code>

second, sort all signatures lexicographically:

<code>
2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae
fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9
</code>

third, map to partial derivation paths by applying (HTPDM):
<code>
11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310
64734/11054/56229/27636/2144/8119/8702/39772/13197/4334/17054/41039/44629/4534/36799/36793
</code>

forth, join partial paths:
<code>
11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310/64734/11054/56229/27636/2144/8119/8702/39772/13197/4334/17054/41039/44629/4534/36799/36793
</code>

fifth, compute child public key:
<code>
xpub7EtARQ7EPnCLNDWPy4QDJn2gyJViLzDiZF3VLeZeUQAMiq21GWvtSmnutwWv6sfEbWNJQukYgMz2GLyiWpWC2AbLSziz345gDwVDigN4EBE
</code>

lastly, compute address:
<code>
19gcjDDzBoDBAieh9kZvFQFSbcLWkcpoVo
</code>

verification example 1 (negative test):

As an input, we have a contract that consists two documents, below are contents:

document 1:
<code>
baz
</code>

first, apply the hash function:

<code>
baa5a0964d3320fbc0c6a922140453c8513ea24ab8fd0577034804a967248096
</code>

second, compute the partial derivation path:
<code>
47781/41110/19763/8443/49350/43298/5124/21448/20798/41546/47357/1399/840/1193/26404/32918
</code>

third, compute address:
<code>
16yfhaGao2QCJKwmMxVbPYkSnts25iLaza
</code>

Address matching failed as expected, verification will only succeed if we use the same documents that we use for the address generation.

==Reference==

* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]
* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]
* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]
* [[https://arxiv.org/abs/1212.3257|Homomorphic Payment Addresses and the Pay-to-Contract Protocol]]

==Copyright==

This document is placed in the public domain.
